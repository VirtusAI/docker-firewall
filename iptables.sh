#!/bin/bash
#
# This script outputs iptables rules compatible with iptables-restore.
# The rules are designed to block traffic to the public interface 
# that is not from whitelisted addresses before they reach the 
# standard Docker routing rules.
#
# Expects the following environment variables:
#  - FW_SERVICE   friendly name for the service
#  - FW_PROTO     protocol to allow (tcp|udp)
#  - FW_PORTS     comma-separated list of port numbers to allow
#
# Optional:
#  - FW_STATIC    comma-separated list of IPs to always allow
#  - FW_DISABLE   if set to 1, disables the firewall rules
#
# Example:
#  $ iptables.sh | iptables-restore --counters --noflush

# Get public interface name
IF=$(ip route | awk '/^default/{print $5}')

service=$FW_SERVICE
protos=$FW_PROTO
ports=$FW_PORTS
static=$FW_STATIC

[ -n "$service" ] || { echo "Service is not set."; exit 1; }
[ -n "$protos" ] || { echo "Protocol is not set."; exit 1; }
[ -n "$ports" ] || { echo "Ports is not set."; exit 1; }

prefix=DOCKER-$service
chain=$prefix-$(openssl rand -hex 3)

echo "# Generated by iptables.sh: $service $protos $ports"
echo "# Public interface: $IF"
iptables-save -t mangle | sed "/$prefix-/d;/^COMMIT$/d;/^#/d"

# Allow the firewall to be disabled
if [[ "$FW_DISABLE" = "1" ]]; then
  echo COMMIT
  exit 0
fi

# Add new chain
echo -N ${chain}

# Allow source IPs
# Example: echo A ${chain} -s 10.10.10.10 -j RETURN -m comment --comment "primary:test3.local.lan::"
for addr in ${static//,/ }; do
  echo -A ${chain} -s ${addr} -j RETURN -m comment --comment "static-entry"
done

# Deny all other IPs
echo -A ${chain} -j DROP

# Insert rule into PREROUTING
for proto in ${protos//,/$'\n'}; do
  for port in ${ports//,/$'\n'}; do
    echo -A PREROUTING -i $IF -p ${proto} -m ${proto} --dport ${port} -j ${chain}
  done
done

echo COMMIT

